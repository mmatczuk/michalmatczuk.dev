<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>michalmatczuk.dev/posts/gocqlx-a-productivity-toolkit-for-scylla-in-go/</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/svg+xml href=/favicon.svg><meta property="og:title" content="Shaving 40% Off Google’s B-Tree Implementation with Go Generics"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://michalmatczuk.dev/posts/gocqlx-a-productivity-toolkit-for-scylla-in-go/"><meta property="article:published_time" content="2022-04-27T00:00:00+00:00"><meta name=twitter:title content="Shaving 40% Off Google’s B-Tree Implementation with Go Generics"><meta name=twitter:description content="This blog post has been first published in ScyllaDB blog.
Discussions: Hacker News | Reddit.
There are many reasons to be excited about generics in Go. In this blog post I&rsquo;m going to show how, using the generics, we got a 40% performance gain in an already well optimized package, the Google B-Tree implementation.
A B-Tree is a kind of self-balancing tree. For the purpose of this blog post it&rsquo;s sufficient to say that it is a collection."><link rel=stylesheet href=https://michalmatczuk.dev/css/terminal.min.css><link rel=stylesheet href=https://michalmatczuk.dev/css/syntax.min.css><link rel=stylesheet href=https://michalmatczuk.dev/css/overwrite.css><link rel=stylesheet href=https://michalmatczuk.dev/css/normalize.min.css><link rel=stylesheet href=https://michalmatczuk.dev/css/fontawesome.min.css><link rel=stylesheet href=https://michalmatczuk.dev/css/brands.min.css><link rel=stylesheet href=https://michalmatczuk.dev/css/solid.min.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-EG92897MK2"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EG92897MK2")</script></head><body class=terminal><div class=container><div class=terminal-nav><header class=terminal-logo><div class="logo terminal-prompt"><a href=https://michalmatczuk.dev class=no-style>michalmatczuk.dev</a>:~#
<a href=https://michalmatczuk.dev/posts>posts</a>/</div></header><nav class=terminal-menu><ul vocab="https://schema.org/" typeof="BreadcrumbList"><li><a href=https://michalmatczuk.dev/posts/ typeof="ListItem">posts/</a></li><li><a href=https://michalmatczuk.dev/talks/ typeof="ListItem">talks/</a></li><li><a href=https://michalmatczuk.dev/projects/ typeof="ListItem">projects/</a></li><li><a href=https://michalmatczuk.dev/about/ typeof="ListItem">about/</a></li></ul></nav></div></div><div class="container animated zoomIn fast"><h1>Shaving 40% Off Google’s B-Tree Implementation with Go Generics</h1><p><em>This blog post has been first published in <a href=https://www.scylladb.com/author/mmatczuk/>ScyllaDB blog</a>.</em></p><p><strong>Discussions: <a href="https://news.ycombinator.com/item?id=31182645">Hacker News</a> | <a href=https://www.reddit.com/r/golang/comments/ud9l2v/shaving_40_off_googles_btree_implementation_with/>Reddit</a>.</strong></p><p>There are many reasons to be excited about generics in Go.
In this blog post I&rsquo;m going to show how, using the generics, we got a 40% performance gain in an already well optimized package, the <a href=https://github.com/google/btree>Google B-Tree</a> implementation.</p><p>A <a href=https://en.wikipedia.org/wiki/B-tree>B-Tree</a> is a kind of self-balancing tree.
For the purpose of this blog post it&rsquo;s sufficient to say that it is a collection.
You can add, remove, get or iterate over its elements.
The <a href=https://github.com/google/btree>Google B-Tree</a> is well optimized, measures are taken to make sure memory consumption is correct.
There is a benchmark for every exported method.
The benchmark results show that there are zero allocations in the B-Tree code for all operations but cloning.
Probably it would be hard to further optimize using traditional techniques.</p><h2 id=making-faster-b-trees-with-generics>Making Faster B-Trees with Generics</h2><p>While working on a new Scylla Go Driver with students of University of Warsaw, we ported the B-tree code to <a href=https://github.com/Michal-Leszczynski/btree>generics</a>.
The initial result: the generics code is faster by 20 to 30 percent according to the Google benchmarks (<a href=https://github.com/google/btree/issues/41>link to issue we opened</a>).
Below a full benchmark comparison done with benchstat.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>name                                 old time/op    new time/op    delta
</span></span><span class=line><span class=cl>Insert-8                                121ns ± 1%      89ns ± 1%   -27.04%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>Seek-8                                  115ns ± 1%      78ns ± 0%   -31.56%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteInsert-8                          248ns ± 0%     185ns ± 1%   -25.51%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteInsertCloneOnce-8                 249ns ± 0%     187ns ± 1%   -25.07%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteInsertCloneEachTime-8            1.10µs ± 5%    0.61µs ± 1%   -44.45%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>Delete-8                                138ns ± 1%     101ns ± 1%   -26.62%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>Get-8                                   102ns ± 1%      71ns ± 0%   -30.46%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>GetCloneEachTime-8                      148ns ± 1%     115ns ± 0%   -21.79%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>Ascend-8                               40.2µs ± 1%    31.7µs ± 0%   -21.18%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>Descend-8                              39.3µs ± 1%    30.7µs ± 1%   -21.91%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>AscendRange-8                          72.3µs ± 1%    57.6µs ± 1%   -20.39%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DescendRange-8                         92.9µs ± 1%    77.6µs ± 1%   -16.45%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>AscendGreaterOrEqual-8                 52.6µs ± 0%    39.7µs ± 1%   -24.65%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DescendLessOrEqual-8                   74.3µs ± 1%    59.9µs ± 1%   -19.40%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteAndRestore/CopyBigFreeList-8     4.10ms ± 0%    3.02ms ± 0%   -26.39%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteAndRestore/Copy-8                4.23ms ± 1%    3.05ms ± 0%   -27.75%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteAndRestore/ClearBigFreelist-8    2.06ms ± 1%    1.49ms ± 0%   -27.41%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteAndRestore/Clear-8               2.25ms ± 1%    1.53ms ± 0%   -31.88%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>name                                 old alloc/op   new alloc/op   delta
</span></span><span class=line><span class=cl>Insert-8                                35.6B ± 4%     18.4B ± 3%   -48.31%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>Seek-8                                  7.00B ± 0%     0.00B       -100.00%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteInsert-8                          0.00B          0.00B           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteInsertCloneOnce-8                 0.00B          0.00B           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteInsertCloneEachTime-8            2.98kB ± 5%    1.91kB ± 1%   -36.16%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>Delete-8                                0.00B          0.00B           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>Get-8                                   0.00B          0.00B           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>GetCloneEachTime-8                      48.0B ± 0%     48.0B ± 0%      ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>Ascend-8                                0.00B          0.00B           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>Descend-8                               0.00B          0.00B           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>AscendRange-8                           0.00B          0.00B           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>DescendRange-8                          0.00B          0.00B           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>AscendGreaterOrEqual-8                  0.00B          0.00B           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>DescendLessOrEqual-8                    0.00B          0.00B           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteAndRestore/CopyBigFreeList-8      274kB ± 0%     141kB ± 0%   -48.28%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteAndRestore/Copy-8                 866kB ± 1%     452kB ± 1%   -47.76%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteAndRestore/ClearBigFreelist-8      484B ± 8%      356B ±11%   -26.30%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteAndRestore/Clear-8                544kB ± 2%     286kB ± 1%   -47.35%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>name                                 old allocs/op  new allocs/op  delta
</span></span><span class=line><span class=cl>Insert-8                                 0.00           0.00           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>Seek-8                                   0.00           0.00           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteInsert-8                           0.00           0.00           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteInsertCloneOnce-8                  0.00           0.00           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteInsertCloneEachTime-8              11.0 ± 0%      11.0 ± 0%      ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>Delete-8                                 0.00           0.00           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>Get-8                                    0.00           0.00           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>GetCloneEachTime-8                       3.00 ± 0%      3.00 ± 0%      ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>Ascend-8                                 0.00           0.00           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>Descend-8                                0.00           0.00           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>AscendRange-8                            0.00           0.00           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>DescendRange-8                           0.00           0.00           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>AscendGreaterOrEqual-8                   0.00           0.00           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>DescendLessOrEqual-8                     0.00           0.00           ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteAndRestore/CopyBigFreeList-8       11.8 ±24%      10.2 ±18%      ~     <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.222 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteAndRestore/Copy-8                 1.16k ± 2%     1.16k ± 1%      ~     <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.595 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteAndRestore/ClearBigFreelist-8      1.00 ± 0%      1.00 ± 0%      ~     <span class=o>(</span>all equal<span class=o>)</span>
</span></span><span class=line><span class=cl>DeleteAndRestore/Clear-8                1.05k ± 2%     1.05k ± 1%      ~     <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.595 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span></code></pre></div><p>This is great but within those numbers there is a troubling detail.
The zero allocations is not something that you would normally see given that the functions accept an interface as a parameter.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Item represents a single object in the tree.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Item</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Less tests whether the current item is less than the given argument.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// This must provide a strict weak ordering.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// If !a.Less(b) &amp;&amp; !b.Less(a), we treat this to mean a == b (i.e. we can only
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// hold one of either a or b in the tree).
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>Less</span><span class=p>(</span><span class=nx>than</span> <span class=nx>Item</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>BTree</span><span class=p>)</span> <span class=nf>ReplaceOrInsert</span><span class=p>(</span><span class=nx>item</span> <span class=nx>Item</span><span class=p>)</span> <span class=nx>Item</span>
</span></span></code></pre></div><p>For the rest of the blog post we’ll focus on benchmarking the <code>ReplaceOrInsert</code> function responsible for ingesting data.
Let&rsquo;s consider a simplified benchmark.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>btreetest</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;testing&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=s>&#34;github.com/google/btree&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>BenchmarkInsert</span><span class=p>(</span><span class=nx>b</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>B</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>tr</span> <span class=o>:=</span> <span class=nx>btree</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=mi>32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span><span class=p>.</span><span class=nf>ResetTimer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>b</span><span class=p>.</span><span class=nx>N</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=nx>tr</span><span class=p>.</span><span class=nf>ReplaceOrInsert</span><span class=p>(</span><span class=nx>btree</span><span class=p>.</span><span class=nf>Int</span><span class=p>(</span><span class=nx>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The results show even greater improvement: 31% vs.
27%, and allocations drop from 1, in case of the interface based implementation, to 0 in the case of generics.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>name      old time/op    new time/op    delta
</span></span><span class=line><span class=cl>Insert-8     200ns ± 2%     137ns ± 1%   -31.20%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>name      old alloc/op   new alloc/op   delta
</span></span><span class=line><span class=cl>Insert-8     60.0B ± 0%     27.0B ± 0%   -55.00%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>name      old allocs/op  new allocs/op  delta
</span></span><span class=line><span class=cl>Insert-8      1.00 ± 0%      0.00       -100.00%  <span class=o>(</span><span class=nv>p</span><span class=o>=</span>0.008 <span class=nv>n</span><span class=o>=</span>5+5<span class=o>)</span>
</span></span></code></pre></div><p>Let&rsquo;s try to understand what happens here.</p><h2 id=the-additional-allocation>The additional allocation</h2><p>The Google benchmarks operate on a B-tree of integers <a href=https://github.com/google/btree/blob/ac7cc57f11e692c57831c3d9bcffb4b7a649b738/btree.go#L885>hidden by an Item interface</a>.
They use pre-generated random data in a slice.
When an Item is passed to <code>ReplaceOrInsert</code> function the underlying integer is already on the heap, technically we are copying a pointer.
This is not the case when a plain integer needs to be converted to an Item interface — the parameter values start &ldquo;escaping to heap&rdquo;.</p><p>Go has a feature of deciding if a variable you initialized should live in the function&rsquo;s stack or in the heap.
Traditionally the compiler was very &ldquo;conservative&rdquo; and when it saw a function like <code>func bind(v interface{})</code> anything you wanted to pass as v would have to go to heap first.
This is referred to as variable escaping to the heap.
Over the years the compiler has gotten smarter, and calls to local functions or functions in other packages in your project can be optimized, preventing the variables from escaping.
You can check for yourself by running <code>go build -gcflags="-m" .</code> in a Go package.</p><p>In the below example Go can figure out that it&rsquo;s safe to take a pointer to the main functions stack.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>foo</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>A</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>  <span class=nx>B</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>f</span> <span class=o>:=</span> <span class=nx>foo</span><span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=nx>A</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nf>ToString</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nf>ToString</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//go:noinline
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>ToString</span><span class=p>(</span><span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>vv</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>v</span><span class=p>.(</span><span class=kt>int</span><span class=p>);</span> <span class=nx>ok</span> <span class=o>&amp;&amp;</span> <span class=nx>vv</span> <span class=o>==</span> <span class=mi>42</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=nx>Out</span> <span class=p>=</span> <span class=s>&#34;42&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=nx>Out</span> <span class=p>=</span> <span class=s>&#34;24&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>Out</span> <span class=kt>string</span>
</span></span></code></pre></div><p>As you can see the compiler informs us that variables do not escape to heap.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go build -gcflags<span class=o>=</span><span class=s2>&#34;-m&#34;</span> .
</span></span><span class=line><span class=cl><span class=c1># btreetest/e1</span>
</span></span><span class=line><span class=cl>./f.go:17:15: v does not escape
</span></span><span class=line><span class=cl>./f.go:12:11: <span class=m>1</span> does not escape
</span></span><span class=line><span class=cl>./f.go:13:10: f does not escape
</span></span></code></pre></div><p>By changing the <code>ToString</code> implementation to</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>//go:noinline
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>ToString</span><span class=p>(</span><span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Out</span> <span class=p>=</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprint</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>we see that the variables and literal values do start escaping.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=err>$</span> <span class=k>go</span> <span class=nx>build</span> <span class=o>-</span><span class=nx>gcflags</span><span class=p>=</span><span class=s>&#34;-m&#34;</span> <span class=p>.</span>
</span></span><span class=line><span class=cl><span class=err>#</span> <span class=nx>btreetest</span><span class=o>/</span><span class=nx>e2</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=o>/</span><span class=nx>f</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>21</span><span class=p>:</span><span class=mi>15</span><span class=p>:</span> <span class=nx>leaking</span> <span class=nx>param</span><span class=p>:</span> <span class=nx>v</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=o>/</span><span class=nx>f</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>22</span><span class=p>:</span><span class=mi>18</span><span class=p>:</span> <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=nx>argument</span> <span class=nx>does</span> <span class=nx>not</span> <span class=nx>escape</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=o>/</span><span class=nx>f</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>16</span><span class=p>:</span><span class=mi>11</span><span class=p>:</span> <span class=mi>42</span> <span class=nx>escapes</span> <span class=nx>to</span> <span class=nx>heap</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=o>/</span><span class=nx>f</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>17</span><span class=p>:</span><span class=mi>10</span><span class=p>:</span> <span class=nx>f</span> <span class=nx>escapes</span> <span class=nx>to</span> <span class=nx>heap</span>
</span></span></code></pre></div><p>In practical examples, when calling a function that accepts an interface as a parameter, the value almost always escapes to heap.
When this happens it not only slows down the function call by the allocation, but also increases the GC pressure.
Why is this important?
<em>The generics approach enables a truly zero allocation API, with zero GC pressure added as we will learn in the remainder of this blog post.</em></p><h2 id=why-is-it-faster>Why is it faster?</h2><p>The B-tree, being a tree, consists of nodes.
Each node holds a list of items.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// items stores items in a node.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>items</span> <span class=p>[]</span><span class=nx>Item</span>
</span></span></code></pre></div><p>When the Item is a pre-generics plain old interface, the value it holds must live separately somewhere on the heap.
The compiler is not able to tell what is the size of an Item.
From the runtime perspective an interface value is an unsafe pointer to data (word), a pointer to its type definition (typ), a pointer to interface definition (ityp); see <a href=https://github.com/golang/go/blob/357c9141369361101345f3048a6b2b3e149299d5/src/reflect/value.go#L180>definitions in the reflect package</a>.
It&rsquo;s easier to digest than the runtime package.
In that case we have items as a slice of int pointers.</p><p>On the other hand, with generic interface</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Item represents a single object in the tree.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Item</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>]</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Less tests whether the current item is less than the given argument.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// This must provide a strict weak ordering.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// If !a.Less(b) &amp;&amp; !b.Less(a), we treat this to mean a == b (i.e. we can only
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// hold one of either a or b in the tree).
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>Less</span><span class=p>(</span><span class=nx>than</span> <span class=nx>T</span><span class=p>)</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>and a generic type definition</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// node is an internal node in a tree.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// It must at all times maintain the invariant that either
</span></span></span><span class=line><span class=cl><span class=c1>//   * len(children) == 0, len(items) unconstrained
</span></span></span><span class=line><span class=cl><span class=c1>//   * len(children) == len(items) + 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>node</span><span class=p>[</span><span class=nx>T</span> <span class=nx>Item</span><span class=p>[</span><span class=nx>T</span><span class=p>]]</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>items</span>    <span class=nx>items</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=nx>children</span> <span class=nx>children</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=nx>cow</span>      <span class=o>*</span><span class=nx>copyOnWriteContext</span><span class=p>[</span><span class=nx>T</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>items are a slice of ints - this reduces the number of small heap objects by a factor of 32.</p><p>Enough of theory, let&rsquo;s try to examine a concrete usage.
For the purpose of this blog I wrote a test program that is a scaled up version of my benchmark code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;github.com/google/btree&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=nx>degree</span> <span class=p>=</span> <span class=mi>1_000</span>
</span></span><span class=line><span class=cl>  <span class=nx>size</span>   <span class=p>=</span> <span class=mi>100_000_000</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>tr</span> <span class=o>:=</span> <span class=nx>btree</span><span class=p>.</span><span class=nx>New</span><span class=p>[</span><span class=nx>btree</span><span class=p>.</span><span class=nx>Int</span><span class=p>](</span><span class=nx>degree</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>size</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=nx>tr</span><span class=p>.</span><span class=nf>ReplaceOrInsert</span><span class=p>(</span><span class=nx>btree</span><span class=p>.</span><span class=nf>Int</span><span class=p>(</span><span class=nx>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We are adding 100 million integers, and the degree of the B-tree (number of items in a node) is 1k.
There are two versions of this program: one uses generics, the other plain old interface.
The difference in code is minimal, it&rsquo;s literally changing <code>btree.New(degree)</code> to <code>btree.New[btree.Int](degree)</code> in line X.
Let&rsquo;s compare data gathered by running both versions under <code>/usr/bin/time -l -p</code>.</p><table><thead><tr><th></th><th>generics</th><th>interface</th><th>delta</th></tr></thead><tbody><tr><td>real</td><td>11.49</td><td>16.59</td><td>-30.74%</td></tr><tr><td><strong>user</strong></td><td>11.27</td><td>18.61</td><td><strong>-39.44%</strong></td></tr><tr><td><strong>sys</strong></td><td>0.24</td><td>0.6</td><td><strong>-60.00%</strong></td></tr><tr><td><strong>maximum resident set size</strong></td><td>2334212096</td><td>6306217984</td><td><strong>-62.99%</strong></td></tr><tr><td>average shared memory size</td><td>0</td><td>0</td><td></td></tr><tr><td>average unshared data size</td><td>0</td><td>0</td><td></td></tr><tr><td>average unshared stack size</td><td>0</td><td>0</td><td></td></tr><tr><td>page reclaims</td><td>142624</td><td>385306</td><td>-62.98%</td></tr><tr><td>page faults</td><td>0</td><td>0</td><td></td></tr><tr><td>swaps</td><td>0</td><td>0</td><td></td></tr><tr><td>block input operations</td><td>0</td><td>0</td><td></td></tr><tr><td>block output operations</td><td>0</td><td>0</td><td></td></tr><tr><td>messages sent</td><td>0</td><td>0</td><td></td></tr><tr><td>messages received</td><td>0</td><td>0</td><td></td></tr><tr><td>signals received</td><td>600</td><td>843</td><td>-28.83%</td></tr><tr><td>voluntary context switches</td><td>25</td><td>48</td><td>-47.92%</td></tr><tr><td>involuntary context switches</td><td>1652</td><td>2943</td><td>-43.87%</td></tr><tr><td>instructions retired</td><td>204760684966</td><td>288827272312</td><td>-29.11%</td></tr><tr><td>cycles elapsed</td><td>37046278867</td><td>60503503105</td><td>-38.77%</td></tr><tr><td>peak memory footprint</td><td>2334151872</td><td>6308147904</td><td>-63.00%</td></tr><tr><td><strong>HeapObjects</strong></td><td>236884</td><td>50255826</td><td><strong>-99.53%</strong></td></tr><tr><td>HeapAlloc</td><td>2226292560</td><td>6043893088</td><td>-63.16%</td></tr></tbody></table><p>Here using generics solves a version of N+1 problem for slices of interfaces.
Instead of one slice and N integers in heap we now can have just the slice of ints.
The results are profound, the new code behaves better in every aspect.
The wall time duration is down by 40%, context switches are down by 40%, system resources utilization is down by 60% — all thanks to a 99.53% reduction of small heap objects.</p><p>I&rsquo;d like to conclude by taking a look at top CPU utilization.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>go tool pprof -top cpu.pprof
</span></span></code></pre></div><p>Generic:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Type: cpu
</span></span><span class=line><span class=cl>Time: Apr 5, <span class=m>2022</span> at 10:23am <span class=o>(</span>CEST<span class=o>)</span>
</span></span><span class=line><span class=cl>Duration: 11.61s, Total <span class=nv>samples</span> <span class=o>=</span> 11.05s <span class=o>(</span>95.18%<span class=o>)</span>
</span></span><span class=line><span class=cl>Showing nodes accounting <span class=k>for</span> 10.77s, 97.47% of 11.05s total
</span></span><span class=line><span class=cl>Dropped <span class=m>52</span> nodes <span class=o>(</span>cum &lt;<span class=o>=</span> 0.06s<span class=o>)</span>
</span></span><span class=line><span class=cl>     flat  flat%   sum%        cum   cum%
</span></span><span class=line><span class=cl>    4.96s 44.89% 44.89%      4.96s 44.89%  runtime.madvise
</span></span><span class=line><span class=cl>    4.61s 41.72% 86.61%      4.61s 41.72%  runtime.memclrNoHeapPointers
</span></span><span class=line><span class=cl>    0.64s  5.79% 92.40%      0.64s  5.79%  github.com/google/btree.items<span class=o>[</span>...<span class=o>]</span>.find.func1
</span></span><span class=line><span class=cl>    0.19s  1.72% 94.12%      0.83s  7.51%  sort.Search
</span></span><span class=line><span class=cl>    0.08s  0.72% 94.84%      5.82s 52.67%  github.com/google/btree..insert
</span></span><span class=line><span class=cl>    0.08s  0.72% 95.57%      0.08s  0.72%  runtime.mmap
</span></span><span class=line><span class=cl>    0.07s  0.63% 96.20%      0.90s  8.14%  github.com/google/btree.items<span class=o>[</span>...<span class=o>]</span>.find
</span></span><span class=line><span class=cl>    0.05s  0.45% 96.65%      5.88s 53.21%  github.com/google/btree..ReplaceOrInsert
</span></span><span class=line><span class=cl>    0.05s  0.45% 97.10%      4.19s 37.92%  github.com/google/btree..insertAt <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.04s  0.36% 97.47%      0.61s  5.52%  github.com/google/btree..maybeSplitChild
</span></span><span class=line><span class=cl>        <span class=m>0</span>     0% 97.47%      0.57s  5.16%  github.com/google/btree..split
</span></span></code></pre></div><p>Interface:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Type: cpu
</span></span><span class=line><span class=cl>Time: Apr 5, <span class=m>2022</span> at 10:31am <span class=o>(</span>CEST<span class=o>)</span>
</span></span><span class=line><span class=cl>Duration: 16.69s, Total <span class=nv>samples</span> <span class=o>=</span> 18.65s <span class=o>(</span>111.74%<span class=o>)</span>
</span></span><span class=line><span class=cl>Showing nodes accounting <span class=k>for</span> 17.94s, 96.19% of 18.65s total
</span></span><span class=line><span class=cl>Dropped <span class=m>75</span> nodes <span class=o>(</span>cum &lt;<span class=o>=</span> 0.09s<span class=o>)</span>
</span></span><span class=line><span class=cl>     flat  flat%   sum%        cum   cum%
</span></span><span class=line><span class=cl>    9.53s 51.10% 51.10%      9.53s 51.10%  runtime.madvise
</span></span><span class=line><span class=cl>    2.62s 14.05% 65.15%      2.62s 14.05%  runtime.memclrNoHeapPointers
</span></span><span class=line><span class=cl>    1.09s  5.84% 70.99%      1.31s  7.02%  github.com/google/btree.items.find.func1
</span></span><span class=line><span class=cl>    0.93s  4.99% 75.98%      2.73s 14.64%  runtime.scanobject
</span></span><span class=line><span class=cl>    0.67s  3.59% 79.57%      0.67s  3.59%  runtime.heapBits.bits <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.44s  2.36% 81.93%      1.75s  9.38%  sort.Search
</span></span><span class=line><span class=cl>    0.30s  1.61% 83.54%      0.30s  1.61%  runtime.markBits.isMarked <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.27s  1.45% 84.99%      2.03s 10.88%  github.com/google/btree.items.find
</span></span><span class=line><span class=cl>    0.27s  1.45% 86.43%      3.35s 17.96%  runtime.mallocgc
</span></span><span class=line><span class=cl>    0.26s  1.39% 87.83%      0.26s  1.39%  runtime.<span class=o>(</span>*mspan<span class=o>)</span>.refillAllocCache
</span></span><span class=line><span class=cl>    0.25s  1.34% 89.17%      0.60s  3.22%  runtime.greyobject
</span></span><span class=line><span class=cl>    0.24s  1.29% 90.46%      0.26s  1.39%  runtime.heapBits.next <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.23s  1.23% 91.69%      0.23s  1.23%  github.com/google/btree.Int.Less
</span></span><span class=line><span class=cl>    0.20s  1.07% 92.76%      0.20s  1.07%  runtime.memmove
</span></span><span class=line><span class=cl>    0.20s  1.07% 93.83%      0.20s  1.07%  runtime.mmap
</span></span><span class=line><span class=cl>    0.15s   0.8% 94.64%      2.47s 13.24%  github.com/google/btree.<span class=o>(</span>*items<span class=o>)</span>.insertAt <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.12s  0.64% 95.28%      0.27s  1.45%  runtime.findObject
</span></span><span class=line><span class=cl>    0.08s  0.43% 95.71%      5.44s 29.17%  github.com/google/btree.<span class=o>(</span>*node<span class=o>)</span>.insert
</span></span><span class=line><span class=cl>    0.03s  0.16% 95.87%      5.48s 29.38%  github.com/google/btree.<span class=o>(</span>*BTree<span class=o>)</span>.ReplaceOrInsert
</span></span><span class=line><span class=cl>    0.02s  0.11% 95.98%      0.84s  4.50%  github.com/google/btree.<span class=o>(</span>*node<span class=o>)</span>.maybeSplitChild
</span></span><span class=line><span class=cl>    0.02s  0.11% 96.09%      0.45s  2.41%  runtime.convT64
</span></span><span class=line><span class=cl>    0.01s 0.054% 96.14%      9.83s 52.71%  runtime.<span class=o>(</span>*mheap<span class=o>)</span>.allocSpan
</span></span><span class=line><span class=cl>    0.01s 0.054% 96.19%      2.82s 15.12%  runtime.gcDrain
</span></span><span class=line><span class=cl>        <span class=m>0</span>     0% 96.19%      0.78s  4.18%  github.com/google/btree.<span class=o>(</span>*node<span class=o>)</span>.split
</span></span></code></pre></div><p>You can literally see how messy the interface profile is, how gc starts kicking in killing it&mldr;</p><p>It&rsquo;s even more evident when we focus on gc.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>go tool pprof -focus gc -top cpu.pprof
</span></span></code></pre></div><p>Generic:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Type: cpu
</span></span><span class=line><span class=cl>Time: Apr 5, <span class=m>2022</span> at 10:23am <span class=o>(</span>CEST<span class=o>)</span>
</span></span><span class=line><span class=cl>Duration: 11.61s, Total <span class=nv>samples</span> <span class=o>=</span> 11.05s <span class=o>(</span>95.18%<span class=o>)</span>
</span></span><span class=line><span class=cl>Active filters:
</span></span><span class=line><span class=cl>  <span class=nv>focus</span><span class=o>=</span>gc
</span></span><span class=line><span class=cl>Showing nodes accounting <span class=k>for</span> 0.29s, 2.62% of 11.05s total
</span></span><span class=line><span class=cl>     flat  flat%   sum%        cum   cum%
</span></span><span class=line><span class=cl>    0.19s  1.72%  1.72%      0.19s  1.72%  runtime.memclrNoHeapPointers
</span></span><span class=line><span class=cl>    0.02s  0.18%  1.90%      0.02s  0.18%  runtime.<span class=o>(</span>*mspan<span class=o>)</span>.refillAllocCache
</span></span><span class=line><span class=cl>    0.01s  0.09%  1.99%      0.02s  0.18%  runtime.<span class=o>(</span>*fixalloc<span class=o>)</span>.alloc
</span></span><span class=line><span class=cl>    0.01s  0.09%  2.08%      0.01s  0.09%  runtime.<span class=o>(</span>*mheap<span class=o>)</span>.allocNeedsZero
</span></span><span class=line><span class=cl>    0.01s  0.09%  2.17%      0.01s  0.09%  runtime.<span class=o>(</span>*mspan<span class=o>)</span>.init <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.01s  0.09%  2.26%      0.01s  0.09%  runtime.heapBits.bits <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.01s  0.09%  2.35%      0.01s  0.09%  runtime.markrootSpans
</span></span><span class=line><span class=cl>    0.01s  0.09%  2.44%      0.01s  0.09%  runtime.recordspan
</span></span><span class=line><span class=cl>    0.01s  0.09%  2.53%      0.02s  0.18%  runtime.scanobject
</span></span><span class=line><span class=cl>    0.01s  0.09%  2.62%      0.01s  0.09%  runtime.stkbucket
</span></span></code></pre></div><p>Interface:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Type: cpu
</span></span><span class=line><span class=cl>Time: Apr 5, <span class=m>2022</span> at 10:31am <span class=o>(</span>CEST<span class=o>)</span>
</span></span><span class=line><span class=cl>Duration: 16.69s, Total <span class=nv>samples</span> <span class=o>=</span> 18.65s <span class=o>(</span>111.74%<span class=o>)</span>
</span></span><span class=line><span class=cl>Active filters:
</span></span><span class=line><span class=cl>  <span class=nv>focus</span><span class=o>=</span>gc
</span></span><span class=line><span class=cl>Showing nodes accounting <span class=k>for</span> 6.06s, 32.49% of 18.65s total
</span></span><span class=line><span class=cl>Dropped <span class=m>27</span> nodes <span class=o>(</span>cum &lt;<span class=o>=</span> 0.09s<span class=o>)</span>
</span></span><span class=line><span class=cl>     flat  flat%   sum%        cum   cum%
</span></span><span class=line><span class=cl>    2.62s 14.05% 14.05%      2.62s 14.05%  runtime.memclrNoHeapPointers
</span></span><span class=line><span class=cl>    0.93s  4.99% 19.03%      2.73s 14.64%  runtime.scanobject
</span></span><span class=line><span class=cl>    0.67s  3.59% 22.63%      0.67s  3.59%  runtime.heapBits.bits <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.30s  1.61% 24.24%      0.30s  1.61%  runtime.markBits.isMarked <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.27s  1.45% 25.68%      3.35s 17.96%  runtime.mallocgc
</span></span><span class=line><span class=cl>    0.26s  1.39% 27.08%      0.26s  1.39%  runtime.<span class=o>(</span>*mspan<span class=o>)</span>.refillAllocCache
</span></span><span class=line><span class=cl>    0.25s  1.34% 28.42%      0.60s  3.22%  runtime.greyobject
</span></span><span class=line><span class=cl>    0.24s  1.29% 29.71%      0.26s  1.39%  runtime.heapBits.next <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.12s  0.64% 30.35%      0.27s  1.45%  runtime.findObject
</span></span><span class=line><span class=cl>    0.08s  0.43% 30.78%      0.08s  0.43%  runtime.spanOf <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.06s  0.32% 31.10%      0.06s  0.32%  runtime.<span class=o>(</span>*mspan<span class=o>)</span>.base <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.06s  0.32% 31.42%      0.06s  0.32%  runtime.<span class=o>(</span>*mspan<span class=o>)</span>.init <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.06s  0.32% 31.74%      0.06s  0.32%  runtime.heapBitsSetType
</span></span><span class=line><span class=cl>    0.04s  0.21% 31.96%      0.04s  0.21%  runtime.<span class=o>(</span>*mSpanStateBox<span class=o>)</span>.get <span class=o>(</span>inline<span class=o>)</span>
</span></span><span class=line><span class=cl>    0.04s  0.21% 32.17%      0.04s  0.21%  runtime.pthread_kill
</span></span><span class=line><span class=cl>    0.04s  0.21% 32.39%      0.04s  0.21%  runtime.usleep
</span></span><span class=line><span class=cl>    0.01s 0.054% 32.44%      0.10s  0.54%  runtime.<span class=o>(</span>*mheap<span class=o>)</span>.allocSpan
</span></span><span class=line><span class=cl>    0.01s 0.054% 32.49%      2.82s 15.12%  runtime.gcDrain
</span></span></code></pre></div><p>The generic version spent 0.29s (2.62%) in GC while the interface version spent 6.06s accounting for, hold your breath, 32.49% of the total time!</p><h2 id=conclusion>Conclusion</h2><p>By shifting the implementation from one using interfaces, to one using generics, we were able to significantly improve performance, minimize garbage collection time, and minimize CPU and other resource utilization, such as heap size.
Particularly with heap size, we were able to reduce HeapObjects by 99.53%.</p><p>The future of Go generics is bright especially in the domain of slices.</p><div class=footer><a href=https://github.com/mmatczuk><i class="fa-brands fa-github"></i></a>
<a href=https://twitter.com/michalmatczuk><i class="fa-brands fa-twitter"></i></a>
<a href=https://www.linkedin.com/in/mmatczuk><i class="fa-brands fa-linkedin"></i></a></div></div></body></html>